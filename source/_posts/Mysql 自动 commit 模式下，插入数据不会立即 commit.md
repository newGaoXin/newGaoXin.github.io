---
title: Mysql 自动 commit 模式下，插入数据不会立即 commit
date: 2023-10-13 15:34:10
tags:
- MySQL
- Spring
categories:
- MySQL
description: 在工作中使用 SpringBoot 框架开发项目，新增数据有概率出现后立即刷新页面，没有获取到最新插入的数据，第二次刷新才获取到最新数据的问题记录学习
comments: true
---

## 场景

在项目中

流程一（过程中没有使用事务）：

前端调用后端接口，后端会通过流的形式返回给前端，在最后会将数据持久化到 MySQL 数据库，并返回结束标志返回给前端

流程二：

前端收到结束标志后，会在一秒后调用接口刷新页面，调用查询列表接口，会查询流程一持久化数据并展示

项目技术：Java + SpringBoot + Mybatis-Plus + MySQL



## 期望：

在流程一插入数据，流程二刷新即能获取到，因为在开发过程中只有 insert 一条数据，所以想法是不需要使用事务，并没有在流程中使用Spring 事务



## 结果（问题）：

在流程一和流程二**反复快速的操作中**，会出现流程一插入的数据，流程二中前端拉取列表并**没有获取到最新持久化的数据**



## 解决方案：

在流程一，插入数据时使用Spring 事务，保证在数据插入成功，commit 之后返回结束标志给前端



## 原因：

### 一、MySQL 自动commit 模式下，插入数据不会立即 commit

在自动提交模式下，每次 insert 一条数据就会立即执行，但是并不一定会立即 commit。

在 MySQL 中，自动提交模式下，每个 SQL 语句都会自动成为一个事务，并且在执行完该语句后立即提交（commit）。但是，由于InnoDB 存储引擎采用了写日志（redo log）的机制，即使在自动提交模式下，insert 操作也不一定会立即 commit。

具体来说，当执行 insert 操作时，InnoDB 会将该操作写入到 redo log 中，然后将该操作应用到内存中的数据页（data page）中。此时，该操作的状态为“未提交”。在后续的操作中，如果需要将数据同步到磁盘中，InnoDB会将redo log中的操作应用到磁盘中的数据页中，并将该操作的状态设置为“已提交”。

因此，在自动提交模式下，每次insert一条数据就会立即执行，但是并不一定会立即commit。如果需要立即commit，可以使用MySQL的“commit”命令将数据立即提交到磁盘中。

### 二、自动提交模式下，多久 commit 一次呢

在自动提交模式下，insert一条数据之后多久会commit，这个时间是不确定的，取决于多个因素，包括系统负载、磁盘速度、redo log的大小等等。

在MySQL中，自动提交模式下，每个SQL语句都会自动成为一个事务，并且在执行完该语句后立即提交（commit）。但是，由于InnoDB存储引擎采用了写日志（redo log）的机制，即使在自动提交模式下，insert操作也不一定会立即commit。

具体来说，当执行insert操作时，InnoDB会将该操作写入到redo log中，然后将该操作应用到内存中的数据页（data page）中。此时，该操作的状态为“未提交”。在后续的操作中，如果需要将数据同步到磁盘中，InnoDB会将redo log中的操作应用到磁盘中的数据页中，并将该操作的状态设置为“已提交”。

因此，insert操作何时commit取决于多个因素，包括系统负载、磁盘速度、redo log的大小等等。如果需要立即commit，可以使用MySQL的“commit”命令将数据立即提交到磁盘中。



## 总结：

由于在项目场景中，没有使用事务，所以在 insert 数据持久化到数据库中时，依赖于 MySQL 数据库到自动 commit ，而自动 commit 并不会在每次 insert 之后都会执行，而 commit 时间有取决于系统负载、磁盘速度、redo log的大小等等因素

当时这个问题也是在开发线测试的时候发现的，开发线的机器资源紧张，或许在 insert 之后，机器资源被其他应用抢占，在流程二结束后，MySQL 抢占到机器资源，持久化到数据库，导致前端并没有拉取到最新数据